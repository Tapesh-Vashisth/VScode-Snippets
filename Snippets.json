{
	"binary exponentiation": {
		"prefix": "binary exponentiation",
		"body": [
			"long long binpow(long long a, long long b) {",
			"\tlong long res = 1;",
			"\twhile (b > 0) {",
			"\t\tif (b & 1)",
			"\t\t\tres = res * a;",
			"\t\ta = a * a;",
			"\t\tb >>= 1;",
			"\t}",
			"\treturn res;",
			"}"
		],
		"description": "finds a raise to b in log(b)"
	},

	"extended euclidean": {
		"prefix": "extend euclidean",
		"body": [
			"int gcd(int a, int b, int& x, int& y) {",
			"\tif (b == 0) {",
			"\t\tx = 1;",
			"\t\ty = 0;",
			"\t\treturn a;",
			"\t}",
			"\tint x1, y1;",
			"\tint d = gcd(b, a % b, x1, y1);",
			"\tx = y1;",
			"\ty = x1 - y1 * (a / b);",
			"\treturn d;",
			"}"
		],
		"description": "solves the equation"
	},

	"gcd": {
		"prefix": "gcd",
		"body": [
			"int gcd (int a, int b) {",
			"\tif (b == 0)",
			"\t\treturn a;",
			"\telse",
			"\t\treturn gcd (b, a % b);",
			"}"
		],
		"description": "finds the gcd of two numbers"
	},

	"find any solution": {
		"prefix": "allExtendedEuclidean",
		"body": [
			"bool find_any_solution(int a, int b, int c, int &x0, int &y0, int &g) {",
			"\tg = gcd(abs(a), abs(b), x0, y0);",
			"\tif (c % g) {",
			"\t\treturn false;",
			"\t}",
			"\tx0 *= c / g;",
			"\ty0 *= c / g;",
			"\tif (a < 0) x0 = -x0;",
			"\tif (b < 0) y0 = -y0;",
			"\treturn true;",
			"}"
		],
		"description": "finds the gcd of two numbers"
	},	

	"sieve": {
		"prefix": "sieve",
		"body": [
			"vector <bool> find_any_solution(int n) {",
				"\tvector<bool> is_prime(n+1, true);",
				"\tis_prime[0] = is_prime[1] = false;",
				"\tfor (int i = 2; i * i <= n; i++) {",
				"\t\tif (is_prime[i]) {",
				"\t\t\tfor (int j = i * i; j <= n; j += i)",
				"\t\t\t\tis_prime[j] = false;",
				"\t\t}",
				"\t}",
				"\treturn is_prime;",
			"}"
		],
		"description": "finds the gcd of two numbers"
	},
	
	"graphNumeric": {
		"prefix": "graphNumeric",
		"body": [
			"class graph{",
			"\tlist <int> * l;",
			"\tint v;",
			"\t",
			"\tpublic: ",
			"\t\tgraph(int V){",
			"\t\t\tv = V;",
			"\t\t\tl = new list<int>[v];",
			"\t\t}",
			"",
			"\t\tvoid addEdge(int i, int j, bool undir = true){",
			"\t\t\tl[i].push_back(j);",
			"\t\t\tif (undir){",
			"\t\t\t\tl[j].push_back(i);",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tvoid print(){",
			"\t\t\tfor (int i = 0; i < this->v; i++){",
			"\t\t\t\tcout << i << \"--->\";",
			"\t\t\t\tfor (auto hold: l[i]){",
			"\t\t\t\t\tcout << hold << ' ';",
			"\t\t\t\t}",
			"\t\t\t\tcout << endl;",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tvoid bfs(int source){",
			"\t\t\tqueue <int> q;",
			"\t\t\tvector <bool> visited(this->v, false);",
			"",
			"\t\t\tq.push(source);",
			"\t\t\tvisited[source] = true;",
			"",
			"\t\t\twhile (!q.empty()){",
			"\t\t\t\tint hold = q.front();",
			"\t\t\t\tq.pop();",
			"",
			"\t\t\t\tcout << hold << \" \";",
			"\t\t\t\tfor (auto move: l[hold]){",
			"\t\t\t\t\tif (visited[move] != true){",
			"\t\t\t\t\t\tq.push(move);",
			"\t\t\t\t\t\tvisited[move] = true;",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\t",
			"\t\t\tcout << endl;",
			"\t\t}",
			"",
			"\t\tvoid dfsHelper(int root, vector <bool>& visited){",
			"\t\t\tif (visited[root] == false){",
			"\t\t\t\tvisited[root] = true;",
			"\t\t\t\tcout << root << \" \";",
			"\t\t\t\tfor (auto hold: this->l[root]){",
			"\t\t\t\t\tdfsHelper(hold, visited);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tvoid dfs(int source){",
			"\t\t\tvector <bool> visited(this->v, false);",
			"\t\t\tdfsHelper(source, visited);",
			"\t\t\tcout << endl;",
			"\t\t}",
			"};"
		]
	},

	"starting script": {
		"prefix": "startTemplate",
		"body": [
			"#include <iostream>",
			"#include <vector>",
			"#include <set>",
			"#include <unordered_map>",
			"#include <unordered_set>",
			"#include <map>",
			"#include <stack>",
			"#include <queue>",
			"#include <deque>",
			"#include <algorithm>",
			"#include <numeric>",
			"#include <math.h>",
			"#include <cstring>",
			"#include <time.h>",
			"#include <chrono>",
			"#include <random>",
			"#include <ctime>",
			"#include <iomanip>",
			"using namespace std;",
			"#define gc getchar_unlocked",
			"#define fo(i, n) for (i = 0; i < n; i++)",
			"#define Fo(i, k, n) for (i = k; k < n ? i < n : i > n; k < n ? i += 1 : i -= 1)",
			"#define ll long long",
			"#define deb(x) cout << #x << \"=\" << x << endl",
			"#define deb2(x, y) cout << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl",
			"#define pb push_back",
			"#define mp make_pair",
			"#define ff second",
			"#define ss first",
			"#define all(x) x.begin(), x.end()",
			"#define clr(x) memset(x, 0, sizeof(x));",
			"#define sortall(x) sort(all(x))",
			"#define tr(it, arr) for (auto it = arr.begin(); it != arr.end(); it++)",
			"#define PI 3.1415926535897932384626",
			"typedef pair<int, int> pii;",
			"typedef pair<ll, ll> pl;",
			"typedef vector<int> vi;",
			"typedef vector<ll> vl;",
			"typedef vector<pii> vpii;",
			"typedef vector<pl> vpl;",
			"typedef vector<vi> vvi;",
			"typedef vector<vl> vvl;",
			"const double pi = 3.141592653589793238;",
			"const ll mod = 1e9+7;",
			"",
			"void solve() {",
			"",
			"}",
			"",
			"int main(){",
			"    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
			"    srand(chrono::high_resolution_clock::now().time_since_epoch().count());",
			"    int t = 1;",
			"    cin >> t;",
			"    while (t--) {",
			"        solve();",
			"    }",
			"    return 0;",
			"}"
		],
		"description": "starting script"
	},
	"MonoStacks": {
		"prefix": "monostacks",
		"body": [
			"stack <int> s;",
			"vector <int> max_left;",
			"vector <int> max_right;",
			"vector <int> min_left;",
			"vector <int> min_right;",
			"// max_left ",
			"for (int i = 0; i < n; i++) {",
			"    if (s.empty()) {",
			"        max_left.push_back(-1);",
			"        s.push(i);",
			"    } else {",
			"        if (store[s.top()] >= store[i]) {",
			"            max_left.push_back(s.top());",
			"            s.push(i);",
			"        } else {",
			"            while (!s.empty() && store[s.top()] < store[i]) {",
			"                s.pop();",
			"            }",
			"",
			"            if (s.empty()) {",
			"                max_left.push_back(-1);",
			"                s.push(i);",
			"            } else {",
			"                max_left.push_back(s.top());",
			"                s.push(i);",
			"            }",
			"        }",
			"    }",
			"}",
			"",
			"s = stack<int>();",
			"// max_right ",
			"for (int i = n - 1; i >= 0; i--) {",
			"    if (s.empty()) {",
			"        max_right.push_back(store.size());",
			"        s.push(i);",
			"    } else {",
			"        if (store[s.top()] > store[i]) {",
			"            max_right.push_back(s.top());",
			"            s.push(i);",
			"        } else {",
			"            while (!s.empty() && store[s.top()] <= store[i]) {",
			"                s.pop();",
			"            }",
			"",
			"            if (s.empty()) {",
			"                max_right.push_back(store.size());",
			"                s.push(i);",
			"            } else {",
			"                max_right.push_back(s.top());",
			"                s.push(i);",
			"            }",
			"        }",
			"    }",
			"}",
			"",
			"reverse(max_right.begin(), max_right.end());",
			"",
			"s = stack<int>();",
			"// min_left ",
			"for (int i = 0; i < n; i++) {",
			"    if (s.empty()) {",
			"        min_left.push_back(-1);",
			"        s.push(i);",
			"    } else {",
			"        if (store[s.top()] <= store[i]) {",
			"            min_left.push_back(s.top());",
			"            s.push(i);",
			"        } else {",
			"            while (!s.empty() && store[s.top()] > store[i]) {",
			"                s.pop();",
			"            }",
			"",
			"            if (s.empty()) {",
			"                min_left.push_back(-1);",
			"                s.push(i);",
			"            } else {",
			"                min_left.push_back(s.top());",
			"                s.push(i);",
			"            }",
			"        }",
			"    }",
			"}",
			"",
			"s = stack<int>();",
			"// min_right ",
			"for (int i = n - 1; i >= 0; i--) {",
			"    if (s.empty()) {",
			"        min_right.push_back(store.size());",
			"        s.push(i);",
			"    } else {",
			"        if (store[s.top()] < store[i]) {",
			"            min_right.push_back(s.top());",
			"            s.push(i);",
			"        } else {",
			"            while (!s.empty() && store[s.top()] >= store[i]) {",
			"                s.pop();",
			"            }",
			"",
			"            if (s.empty()) {",
			"                min_right.push_back(store.size());",
			"                s.push(i);",
			"            } else {",
			"                min_right.push_back(s.top());",
			"                s.push(i);",
			"            }",
			"        }",
			"    }",
			"}",
			"",
			"reverse(min_right.begin(), min_right.end());"
		],
		"description": "MonoStacks"
	},
	"factors": {
		"prefix": "factors",
		"body": [
			"vl factors(ll n) {",
			"    vl store;",
			"",
			"    for (ll i = 1; i*i <= n; i++) {",
			"        if (n % i == 0) {",
			"            store.push_back(i);",
			"            if (i != n/i) {",
			"                store.push_back(n/i);",
			"            }",
			"        }",
			"    }",
			"",
			"    return store;",
			"}"
		],
		"description": "factors"
	},
	"identity": {
		"prefix": "identity",
		"body": [
			"vector <vector <int>> identity(int n) {",
			"    vector <vector <int>> iden (n, vector <int> (n, 0));",
			"",
			"    for (int i = 0; i < n; i++) {",
			"        for (int j = 0; j < n; j++) {",
			"            if (i == j) {",
			"                iden[i][j] = 1;",
			"            }",
			"        }",
			"    }",
			"",
			"    return iden;",
			"}"
		],
		"description": "identity"
	},
	"multiplyMatrix": {
		"prefix": "multiplyMatrix",
		"body": [
			"vector <vector <int>> multiplyMatrix (vector <vector <int>> & first, vector <vector <int>> & second) {",
			"    vector <vector <int>> mul;",
			"    if (first[0].size() != second.size()) {",
			"        return mul;",
			"    }",
			"",
			"",
			"    mul = vector <vector <int>> (first.size(), vector <int> (second[0].size(), 0));",
			"",
			"    for (int i = 0; i < first.size(); i++) {",
			"        for (int j = 0; j < second[0].size(); j++) {",
			"            int temp = 0;",
			"            for (int k = 0; k < second.size(); k++) {",
			"                temp += first[i][k] * second[k][j];",
			"            }",
			"            mul[i][j] = temp;",
			"        }",
			"    }",
			"",
			"    return mul;",
			"}"
		],
		"description": "multiplyMatrix"
	},
	"powerMatrix": {
		"prefix": "powerMatrix",
		"body": [
		  "vector <vector <int>> identity(int n) {",
		  "    vector <vector <int>> iden (n, vector <int> (n, 0));",
		  "",
		  "    for (int i = 0; i < n; i++) {",
		  "        for (int j = 0; j < n; j++) {",
		  "            if (i == j) {",
		  "                iden[i][j] = 1;",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    return iden;",
		  "}",
		  "",
		  "",
		  "vector <vector <int>> powerMatrix(vector <vector<int>> input, int k) {",
		  "    vector <vector <int>> mul = input;",
		  "    vector <vector <int>> ans = identity(input.size());",
		  "    while (k) {",
		  "        if (k & 1) {",
		  "            ans = multiplyMatrix(ans, mul);",
		  "        }",
		  "",
		  "        mul = multiplyMatrix(mul, mul);",
		  "        ",
		  "        k = k >> 1;",
		  "    }",
		  "    return ans;",
		  "}"
		],
		"description": "powerMatrix"
	},
	"nthfibo": {
		"prefix": "nthfibo",
		"body": [
		  "",
		  "vector <vector <int>> multiplyMatrix (vector <vector <int>> & first, vector <vector <int>> & second) {",
		  "    vector <vector <int>> mul;",
		  "    if (first[0].size() != second.size()) {",
		  "        return mul;",
		  "    }",
		  "",
		  "",
		  "    mul = vector <vector <int>> (first.size(), vector <int> (second[0].size(), 0));",
		  "",
		  "    for (int i = 0; i < first.size(); i++) {",
		  "        for (int j = 0; j < second[0].size(); j++) {",
		  "            int temp = 0;",
		  "            for (int k = 0; k < second.size(); k++) {",
		  "                temp += first[i][k] * second[k][j];",
		  "            }",
		  "            mul[i][j] = temp;",
		  "        }",
		  "    }",
		  "",
		  "    return mul;",
		  "}",
		  "",
		  "vector <vector <int>> baseMatrix() {",
		  "    vector <vector <int>> base = {{1}, {0}};",
		  "    return base;",
		  "}",
		  "",
		  "vector <vector <int>> mulMatrix() {",
		  "    vector <vector <int>> mul = {{1, 1}, {1, 0}};",
		  "    return mul;",
		  "}",
		  "",
		  "",
		  "vector <vector <int>> identity(int n) {",
		  "    vector <vector <int>> iden (n, vector <int> (n, 0));",
		  "",
		  "    for (int i = 0; i < n; i++) {",
		  "        for (int j = 0; j < n; j++) {",
		  "            if (i == j) {",
		  "                iden[i][j] = 1;",
		  "            }",
		  "        }",
		  "    }",
		  "",
		  "    return iden;",
		  "}",
		  "",
		  "",
		  "vector <vector <int>> powerMatrix(vector <vector<int>> input, int k) {",
		  "    vector <vector <int>> mul = input;",
		  "    vector <vector <int>> ans = identity(input.size());",
		  "    while (k) {",
		  "        if (k & 1) {",
		  "            ans = multiplyMatrix(ans, mul);",
		  "        }",
		  "",
		  "        mul = multiplyMatrix(mul, mul);",
		  "        ",
		  "        k = k >> 1;",
		  "    }",
		  "    return ans;",
		  "}",
		  "",
		  "int fibonacci_by_binomial_exponentiation(int n) {",
		  "    if (n == 1 || n == 2) {",
		  "        return n - 1;",
		  "    }",
		  "",
		  "    vector <vector <int>> base = baseMatrix();",
		  "    vector <vector <int>> mul = mulMatrix();",
		  "    vector <vector <int>> multopower = powerMatrix(mul, n - 2);",
		  "    vector <vector <int>> result = multiplyMatrix(multopower, base);",
		  "",
		  "    // for (int i = 0; i < result.size(); i++) {",
		  "    //     for (int j = 0; j < result[0].size(); j++) {",
		  "    //         cout << result[i][j] << \" \";",
		  "    //     }",
		  "    //     cout << endl;",
		  "    // }",
		  "",
		  "    return result[0][0];",
		  "}"
		],
		"description": "nthfibo"
	},
	"printMatrix": {
		"prefix": "printMatrix",
		"body": [
		  "for (int i = 0; i < first.size(); i++) {",
		  "\tfor (int j = 0; j < first[i].size(); j++) {",
		  "\t\tcout << first[i][j] << \" \";",
		  "\t}",
		  "\tcout << endl;",
		  "}"
		],
		"description": "printMatrix"
	},
	"printArray": {
		"prefix": "printArray",
		"body": [
		  "for (int i = 0; i < first.size(); i++) {",
		  "\tcout << first[i] << \" \";",
		  "}",
		  "cout << endl;"
		],
		"description": "printArray"
	},
	"BitFunctions": {
		"prefix": "BitMagic",
		"body": [
			"long long odd_even(long long x){",
			"    return (1&x);",
			"}",
			"",
			"long long getithbit(long long x, long long i){",
			"    long long bit = (long long)1 << (i - 1);",
			"    return (x & bit ? 1 : 0);",
			"}",
			"",
			"long long clearithbit(long long x, long long i){",
			"    long long bit = ~((long long)1 << (i - 1));",
			"    return (x & bit);",
			"}",
			"",
			"long long setithbit(long long x, long long i){",
			"    return (x | ((long long)1 << (i - 1)));",
			"}",
			"",
			"long long updateithbit(long long x, long long i, long long v){",
			"    long long bit = clearithbit(x, i);",
			"    return (bit | (v << (i - 1)));",
			"}",
			"",
			"long long clearlastibits(long long x, long long i){",
			"    return (x & (~(long long)0 << i));",
			"}",
			"",
			"long long clearbitsinrange(long long x, long long i, long long j){",
			"    long long mask = ~((~((~(long long)0) << (j - i + 1))) << i);",
			"    return x & mask;",
			"}",
			"",
			"long long replacebits(long long x, long long y, long long i, long long j){",
			"    long long updated = clearbitsinrange(x, i, j);",
			"    return updated | (y << i); ",
			"}",
			"",
			"long long powerof2(long long x){",
			"    if ((x & (x - 1)) == 0){",
			"        return 1;",
			"    }else{",
			"        return 0;",
			"    }",
			"}",
			"",
			"",
			"long long powerof4(long long x){",
			"    return (!(x & (x - 1))) && (x & 1431655765);",
			"}",
			"",
			"long long countbits(long long x){",
			"    long long count = 0;",
			"",
			"    while (x){",
			"        x = x & (x - 1);",
			"        count++;",
			"    }",
			"",
			"    return count;",
			"}",
			"",
			"long long countbits2(long long x){",
			"    long long count = 0;",
			"",
			"    while (x){",
			"        count = count + (x & 1);",
			"        x = x >> 1;",
			"    }",
			"",
			"    return count;",
			"}",
			"",
			"long long convertToBinary(long long x){",
			"    static long long multiplier = 1;",
			"    if (x == 0){",
			"        return 0;",
			"    }else{",
			"        multiplier *= 10;",
			"        long long ans = convertToBinary(x/2) + (x%2) * (multiplier/10);",
			"        multiplier /= 10;",
			"        return ans;",
			"    }",
			"}",
			"",
			"long long convertToBinary2(long long x){",
			"    long long ans = 0;",
			"    long long power = 1;",
			"    while (x){",
			"        long long last = (x & 1);",
			"        x = x >> 1;",
			"        ans = ans + last * power;",
			"        power = power * 10;",
			"    }",
			"",
			"    return ans;",
			"}",
			"",
			"long long longest_consecutive_1s(long long n){",
			"    long long max = 0;",
			"    long long count = 0;",
			"    long long decider = 0;",
			"    while (n){",
			"        long long bit = n&1;",
			"",
			"        if (bit == 0 && decider == 1){",
			"            count = 0;",
			"        }",
			"",
			"        if (bit == 1 && decider == 1){",
			"            count++;",
			"        }",
			"",
			"        if (bit == 1 && decider == 0){",
			"            decider = 1;",
			"            count++;",
			"        }",
			"",
			"        if (max < count){",
			"            max = count;",
			"        }",
			"        n = n >> 1;",
			"    } ",
			"",
			"    return max;  ",
			"}",
			"void imp() {",
			"  int x = 5328; // 00000000000000000001010011010000",
			"  cout << __builtin_clz(x) << \"\\n\"; // 19",
			"  cout << __builtin_ctz(x) << \"\\n\"; // 4",
			"  cout << __builtin_popcount(x) << \"\\n\"; // 5",
			"  cout << __builtin_parity(x) << \"\\n\"; // 1",
			"}"
		],
		"description": "BitFunctions"
	},
	"mergeSorted": {
		"prefix": "mergeSorted",
		"body": [
			"vector <int> mergeSorted(vector <int> & first, vector <int> & second) {",
			"    vector <int> ret;",
			"    int fir = 0;",
			"    int sec = 0;",
			"    while (fir < first.size() && sec < second.size()) {",
			"        if (first[fir] < second[sec]) {",
			"            ret.push_back(first[fir]);",
			"            fir++;",
			"        } else {",
			"            ret.push_back(second[sec]);",
			"            sec++;",
			"        }",
			"    }",
			"",
			"    while (fir < first.size()) {",
			"        ret.push_back(first[fir]);",
			"        fir++;",
			"    }",
			"",
			"    while (sec < second.size()) {",
			"        ret.push_back(second[sec]);",
			"        sec++;",
			"    }",
			"",
			"    return ret;",
			"}"
		],
		"description": "mergeSorted"
	},
	"trie": {
		"prefix": "trie",
		"body": [
			"class node {",
			"public:",
			"    bool end;",
			"    vector <node *> routes;",
			"",
			"    node() {",
			"        end = false;",
			"        routes = vector <node *> (26, NULL);",
			"    }       ",
			"};",
			"",
			"class Trie {",
			"public:",
			"    node * root;",
			"",
			"    Trie() {",
			"        root = new node();",
			"    }",
			"    ",
			"    void insert(string word) {",
			"        node * hold = root;",
			"        for (auto it: word) {",
			"            if (hold->routes[it - 'a'] != NULL) {",
			"                hold = hold->routes[it - 'a'];",
			"            } else {",
			"                node * temp = new node();",
			"                hold->routes[it - 'a'] = temp;",
			"                hold = hold->routes[it - 'a'];",
			"            }",
			"        }",
			"",
			"        hold->end = true;",
			"    }",
			"    ",
			"    bool search(string word) {",
			"        node * hold = root;",
			"        for (auto it: word) {",
			"            if (hold->routes[it - 'a'] != NULL) {",
			"                hold = hold->routes[it - 'a'];",
			"            } else {",
			"                return false;",
			"            }",
			"        }",
			"",
			"        if (hold->end == true) {",
			"            return true;",
			"        }",
			"",
			"        return false;",
			"    }",
			"    ",
			"    bool startsWith(string prefix) {",
			"        node * hold = root;",
			"        for (auto it: prefix) {",
			"            if (hold->routes[it - 'a'] == NULL) {",
			"                return false;",
			"            }",
			"            hold = hold->routes[it - 'a'];",
			"        }",
			"",
			"        return true;",
			"    }",
			"};"
		],
		"description": "trie"
	},
	"subsets": {
		"prefix": "subsets",
		"body": [
			"vector <vector <int>> generate(vector <int> elements) {",
			"    vector <vector <int>> ans;",
			"    int n = elements.size();",
			"",
			"    for (int i = 0; i < (1 << n); i++) {",
			"        vector <int> temp = {};",
			"        int mask = i;",
			"        int pos = 0;",
			"        while (mask) {",
			"            int decider = mask & 1;",
			"            if (decider) {",
			"                temp.push_back(elements[pos]);",
			"            }",
			"            pos++;",
			"            mask = mask >> 1;",
			"        }",
			"",
			"        ans.push_back(temp);",
			"    }",
			"",
			"    return ans;",
			"}"
		],
		"description": "subsets"
	},
	"DSU": {
		"prefix": "DSU",
		"body": [
			"class DSU {",
			"    private:",
			"        vector <int> parent;",
			"",
			"    public:",
			"        DSU(int n) {",
			"            parent.resize(n);",
			"            for(int i = 0; i<n; i++) parent[i] = i;",
			"        }",
			"",
			"        int find(int ele) {",
			"            if (parent[ele] == ele) {",
			"                return ele;",
			"            } ",
			"",
			"            int par = find(parent[ele]);",
			"",
			"            parent[ele] = par;",
			"",
			"            return par;",
			"        }",
			"",
			"",
			"        void U(int a, int b) {",
			"            int p1 = find(a);",
			"            int p2 = find(b);",
			"",
			"            parent[a] = p1;",
			"            parent[b] = p2;",
			"            ",
			"            if (p1 != p2) {",
			"                parent[p1] = p2;",
			"            }",
			"        }",
			"",
			"        void print() {",
			"            for (int i = 0; i < parent.size(); i++) {",
			"                cout << i << \" \" << parent[i] << endl;",
			"            }",
			"        }",
			"};"
		],
		"description": "DSU"
	},
	"setup for policy based data structure": {
		"prefix": "policyBased",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"typedef tree<int,null_type,less<int>,rb_tree_tag,",
			"tree_order_statistics_node_update> indexed_set;"
		],
		"description": "setup for policy based data structure"
	},
	"Segment tree": {
		"prefix": "segmentTree",
		"body": [
			"// summation",
			"struct segmenttree {",
			"\tint n;",
			"\tvector<int> st;",
			"",
			"\tvoid init(int _n) {",
			"\t\tthis->n = _n;",
			"\t\tst.resize(4 * n, 0);",
			"\t}",
			"",
			"\tvoid build(int start, int ending, int node, vector<int> &v) {",
			"\t// leaf node base case",
			"\tif (start == ending) {",
			"\t\tst[node] = v[start];",
			"\t\treturn;",
			"\t}",
			"",
			"\t\tint mid = (start + ending) / 2;",
			"",
			"\t\t// left subtree is (start,mid)",
			"\t\tbuild(start, mid, 2 * node + 1, v);",
			"",
			"\t\t// right subtree is (mid+1,ending)",
			"\t\tbuild(mid + 1, ending, 2 * node + 2, v);",
			"",
			"\t\tst[node] = st[node * 2 + 1] + st[node * 2 + 2];",
			"\t}",
			"",
			"\tint query(int start, int ending, int l, int r, int node) {",
			"\t\t// non overlapping case",
			"\t\tif (start > r || ending < l) {",
			"\t\t\treturn 0;",
			"\t\t}",
			"",
			"\t\t// complete overlap",
			"\t\tif (start >= l && ending <= r) {",
			"\t\t\treturn st[node];",
			"\t\t}",
			"",
			"\t\t// partial case",
			"\t\tint mid = (start + ending) / 2;",
			"",
			"\t\tint q1 = query(start, mid, l, r, 2 * node + 1);",
			"\t\tint q2 = query(mid + 1, ending, l, r, 2 * node + 2);",
			"",
			"\t\treturn q1 + q2;",
			"\t}",
			"",
			"\tvoid update(int start, int ending, int node, int index, int value) {",
			"\t\t// base case",
			"\t\tif (start == ending) {",
			"\t\t\tst[node] = value;",
			"\t\t\treturn;",
			"\t\t}",
			"",
			"\t\tint mid = (start + ending) / 2;",
			"\t\tif (index <= mid) {",
			"\t\t\t// left subtree",
			"\t\t\tupdate(start, mid, 2 * node + 1, index, value);",
			"\t\t}",
			"\t\telse {",
			"\t\t\t// right",
			"\t\t\tupdate(mid + 1, ending, 2 * node + 2, index, value);",
			"\t\t}",
			"",
			"\t\tst[node] = st[node * 2 + 1] + st[node * 2 + 2];",
			"",
			"\t\treturn;",
			"\t}",
			"",
			"\tvoid build(vector<int> &v) {",
			"\t\tbuild(0, n - 1, 0, v);",
			"\t}",
			"",
			"\tint query(int l, int r) {",
				"\t\treturn query(0, n - 1, l, r, 0);",
			"\t}",
			"",
			"\tvoid update(int x, int y) {",
			"\t\tupdate(0, n - 1, 0, x, y);",
			"\t}",
			"};"
		],
		"description": "Segment tree"
	},
	"lazy propagation": {
		"prefix": "lazyPropagation",
		"body": [
			"// summation",
			"struct segmenttree {",
			"\tint n;",
			"\tvector<int> st, lazy;",
			"",
			"\tvoid init(int _n) {",
			"\t\tthis->n = _n;",
			"\t\tst.resize(4 * n, 0);",
			"\t\tlazy.resize(4 * n, 0);",
			"\t}",
			"",
			"\tvoid build(int start, int ending, int node, vector<int> &v) {",
			"\t\t// leaf node base case",
			"\t\tif (start == ending) {",
			"\t\t\tst[node] = v[start];",
			"\t\t\treturn;",
			"\t\t}",
			"",
			"\t\tint mid = (start + ending) / 2;",
			"",
			"\t\t// left subtree is (start,mid)",
			"\t\tbuild(start, mid, 2 * node + 1, v);",
			"",
			"\t\t// right subtree is (mid+1,ending)",
			"\t\tbuild(mid + 1, ending, 2 * node + 2, v);",
			"",
			"\t\tst[node] = st[node * 2 + 1] + st[node * 2 + 2];",
			"\t}",
			"",
			"\tint query(int start, int ending, int l, int r, int node) {",
			"\t\t// non overlapping case",
			"\t\tif (start > r || ending < l) {",
			"\t\t\treturn 0;",
			"\t\t}",
			"",
			"\t\t// lazy propagation / clear the lazy update",
			"\t\tif (lazy[node] != 0) {",
			"\t\t\t// pending updates",
			"\t\t\t// update the segment tree node",
			"\t\t\tst[node] += lazy[node] * (ending - start + 1);",
			"\t\t\tif (start != ending) {",
			"\t\t\t\t// propagate the updated value",
			"\t\t\t\tlazy[2 * node + 1] += lazy[node];",
			"\t\t\t\tlazy[2 * node + 2] += lazy[node];",
			"\t\t\t}",
			"\t\t\tlazy[node] = 0;",
			"\t\t}",
			"",
			"\t\t// complete overlap",
			"\t\tif (start >= l && ending <= r) {",
			"\t\t\treturn st[node];",
			"\t\t}",
			"",
			"\t\t// partial case",
			"\t\tint mid = (start + ending) / 2;",
			"",
			"\t\tint q1 = query(start, mid, l, r, 2 * node + 1);",
			"\t\tint q2 = query(mid + 1, ending, l, r, 2 * node + 2);",
			"",
			"\t\treturn q1 + q2;",
			"\t}",
			"",
			"\tvoid update(int start, int ending, int node, int l, int r, int value) {",
			"\t\t// non overlapping case",
			"\t\tif (start > r || ending < l) {",
			"\t\t\treturn ;",
			"\t\t}",
			"",
			"\t\t// lazy propagation / clear the lazy update",
			"\t\tif (lazy[node] != 0) {",
			"\t\t\t// pending updates",
			"\t\t\t// update the segment tree node",
			"\t\t\tst[node] += lazy[node] * (ending - start + 1);",
			"\t\t\tif (start != ending) {",
			"\t\t\t\t// propagate the updated value",
			"\t\t\t\tlazy[2 * node + 1] += lazy[node];",
			"\t\t\t\tlazy[2 * node + 2] += lazy[node];",
			"\t\t\t}",
			"\t\t\tlazy[node] = 0;",
			"\t\t}",
			"",
			"\t\t// complete overlap",
			"\t\tif (start >= l && ending <= r) {",
			"\t\t\tst[node] += value * (ending - start + 1);",
			"\t\t\tif (start != ending) {",
			"\t\t\t\tlazy[2 * node + 1] += value;",
			"\t\t\t\tlazy[2 * node + 2] += value;",
			"\t\t\t}",
			"\t\t\treturn;",
			"\t\t}",
			"",
			"\t\t// partial case",
			"\t\tint mid = (start + ending) / 2;",
			"",
			"\t\tupdate(start, mid, 2 * node + 1, l, r, value);",
			"",
			"\t\tupdate(mid + 1, ending, 2 * node + 2, l, r, value);",
			"",
			"\t\tst[node] = st[node * 2 + 1] + st[node * 2 + 2];",
			"",
			"\t\treturn;",
			"\t}",
			"",
			"\tvoid build(vector<int> &v) {",
			"\t\tbuild(0, n - 1, 0, v);",
			"\t}",
			"",
			"\tint query(int l, int r) {",
			"\t\treturn query(0, n - 1, l, r, 0);",
			"\t}",
			"",
			"\tvoid update(int l, int r, int x) {",
			"\t\tupdate(0, n - 1, 0, l, r, x);",
			"\t}",
			"};"
		],
		"description": "lazy propagation"
	},
	"monotonicQueue": {
		"prefix": "monotonicQueue",
		"body": [
			"class monoTonicQueue {",
			"    stack <pair <pair <int, int>, int>> first;",
			"    stack <pair <pair <int, int>, int>> second;",
			"",
			"    public:",
			"        monoTonicQueue() {",
			"            ;",
			"        }    ",
			"",
			"        void pushFirst(int x) {",
			"            int mx = max(x, first.empty() ? INT32_MIN: first.top().first.second);",
			"            int mn = min(x, first.empty() ? INT32_MAX: first.top().first.first);",
			"",
			"            first.push({{mn, mx}, x});",
			"        }  ",
			"",
			"        void pushSecond(int x) {",
			"            int mx = max(x, second.empty() ? INT32_MIN: second.top().first.second);",
			"            int mn = min(x, second.empty() ? INT32_MAX: second.top().first.first);",
			"",
			"            second.push({{mn, mx}, x});",
			"        }  ",
			"",
			"        pair <int, int> minMax() {",
			"            pair <int, int> ret = {INT32_MAX, INT32_MIN};",
			"            ret.first = min(ret.first, min(first.empty() ? INT32_MAX : first.top().first.first, second.empty() ? INT32_MAX : second.top().first.first));",
			"            ret.second = max(ret.second, max(first.empty() ? INT32_MIN : first.top().first.second, second.empty() ? INT32_MIN : second.top().first.second));",
			"",
			"            return ret;",
			"        }",
			"",
			"        void pop() {",
			"            if (second.empty()) {",
			"                while (!first.empty()) {",
			"                    pushSecond(first.top().second);",
			"                    first.pop();",
			"                }",
			"            }",
			"",
			"            second.pop();",
			"        }",
			"",
			"        int size() {",
			"            return first.size() + second.size();",
			"        }",
			"};"
		],
		"description": "monotonicQueue"
	},
	"Single String hash": {
		"prefix": "Shash",
		"body": [
			"class Shash {",
			"    public: ",
			"        vector <long long> prefixHash;",
			"        vector <long long> ppow;",
			"        long long m;",
			"        long long p;",
			"",
			"        Shash() {",
			"            m = 1e9 + 9;",
			"            p = 31;",
			"            prefixHash = {0};",
			"        }",
			"",
			"        Shash(long long m) {",
			"            this->m = m;",
			"        }",
			"",
			"        void calHashes(string & s) {",
			"            long long power = 1;",
			"            for (int i = 0; i < s.size(); i++) {",
			"                ppow.push_back(power);",
			"",
			"                prefixHash.push_back(((prefixHash[i] % m) + ((((s[i] - 'a' + 1) % m) * (ppow[i] % m)) % m)) % m);",
			"",
			"                power = ((power % m) * (p % m)) % m;",
			"            }",
			"        }",
			"",
			"        long long subHash(int low, int high) {",
			"            return (((prefixHash[high] + m - prefixHash[low]) % m) * (ppow[ppow.size() - low - 1] % m)) % m;",
			"        }",
			"};"
		],
		"description": "Single String hash"
	},
	"Double Hash": {
		"prefix": "DShash",
		"body": [
			"class DSHash {",
			"    public:",
			"        long long m1, m2;",
			"        long long p1, p2;",
			"        vector <long long> ppow1;",
			"        vector <long long> ppow2;",
			"        vector <long long> prefixHash1;",
			"        vector <long long> prefixHash2;",
			"",
			"        DSHash() {",
			"            m1 = 1e9 + 7;",
			"            m2 = 1e9 + 9;",
			"            p1 = 31;",
			"            p2 = 43;",
			"            prefixHash1 = {0};",
			"            prefixHash2 = {0};",
			"        }",
			"",
			"        DSHash(long long m1, long long m2, long long p1, long long p2) {",
			"            this->m1 = m1;",
			"            this->m2 = m2;",
			"            this->p1 = p1;",
			"            this->p2 = p2;",
			"            prefixHash1 = {0};",
			"            prefixHash2 = {0};",
			"        }",
			"",
			"        void computeHashes(string & s) {",
			"            long long power1 = 1;",
			"            long long power2 = 1;",
			"            for (int i = 0; i < s.size(); i++) {",
			"                ppow1.push_back(power1);",
			"                ppow2.push_back(power2);",
			"",
			"                prefixHash1.push_back((prefixHash1[i] + (((s[i] - 'A' + 1) * ppow1[i]) % m1)) % m1);",
			"                prefixHash2.push_back((prefixHash2[i] + (((s[i] - 'A' + 1) * ppow2[i]) % m2)) % m2);",
			"",
			"                power1 = ((power1 % m1) * (p1 % m1)) % m1;",
			"                power2 = ((power2 % m2) * (p2 % m2)) % m2;",
			"            }",
			"        }",
			"",
			"        pair <long long, long long> subHash(int low, int high) {",
			"            long long first = (((prefixHash1[high] + m1 - prefixHash1[low]) % m1) * (ppow1[ppow1.size() - low - 1] % m1)) % m1;",
			"            long long second = (((prefixHash2[high] + m2 - prefixHash2[low]) % m2) * (ppow2[ppow2.size() - low - 1] % m2)) % m2;",
			"",
			"            return {first, second};",
			"        }",
			"};"
		],
		"description": "Double Hash"
	},
	"max segment tree": {
		"prefix": "maxSeg",
		"body": [
			"// max",
			"struct segmenttree {",
			"    int n;",
			"    vector<long long> st;",
			"",
			"    void init(int _n) {",
			"        this->n = _n;",
			"        st = vector <long long> (4 * n, 0);",
			"    }",
			"",
			"    void build(int start, int ending, int node, vector<long long> &v) {",
			"    // leaf node base case",
			"    if (start == ending) {",
			"        st[node] = v[start];",
			"        return;",
			"    }",
			"",
			"        int mid = (start + ending) / 2;",
			"",
			"        // left subtree is (start,mid)",
			"        build(start, mid, 2 * node + 1, v);",
			"",
			"        // right subtree is (mid+1,ending)",
			"        build(mid + 1, ending, 2 * node + 2, v);",
			"",
			"        st[node] = max(st[node * 2 + 1], st[node * 2 + 2]);",
			"    }",
			"",
			"    long long query(int start, int ending, int l, int r, int node) {",
			"        // non overlapping case",
			"        if (start > r || ending < l) {",
			"            return 0;",
			"        }",
			"",
			"        // complete overlap",
			"        if (start >= l && ending <= r) {",
			"            return st[node];",
			"        }",
			"",
			"        // partial case",
			"        int mid = (start + ending) / 2;",
			"",
			"        long long q1 = query(start, mid, l, r, 2 * node + 1);",
			"        long long q2 = query(mid + 1, ending, l, r, 2 * node + 2);",
			"",
			"        return max(q1, q2);",
			"    }",
			"",
			"    void update(int start, int ending, int node, int index, long long value) {",
			"        // base case",
			"        if (start == ending) {",
			"            st[node] = value;",
			"            return;",
			"        }",
			"",
			"        int mid = (start + ending) / 2;",
			"        if (index <= mid) {",
			"            // left subtree",
			"            update(start, mid, 2 * node + 1, index, value);",
			"        }",
			"        else {",
			"            // right",
			"            update(mid + 1, ending, 2 * node + 2, index, value);",
			"        }",
			"",
			"        st[node] = max(st[node * 2 + 1], st[node * 2 + 2]);",
			"",
			"        return;",
			"    }",
			"",
			"    void build(vector<long long> &v) {",
			"        build(0, n - 1, 0, v);",
			"    }",
			"",
			"    long long query(int l, int r) {",
			"        return query(0, n - 1, l, r, 0);",
			"    }",
			"",
			"    void update(int x, long long y) {",
			"        update(0, n - 1, 0, x, y);",
			"    }",
			"};"
		],
		"description": "max segment tree"
	},
	"matrix exponentiation": {
		"prefix": "matExpo",
		"body": [
			"const int mod = 1e9 + 7;",
			"const int sz = 2;",
			"",
			"struct Mat {",
			"   int m[sz][sz];",
			"   Mat() {",
			"       memset(m, 0, sizeof(m));",
			"   }",
			"   void identity() {",
			"       for (int i = 0; i < sz; i++) {",
			"           m[i][i] = 1;",
			"       }",
			"   }",
			"   Mat operator* (Mat a) {",
			"       Mat res;",
			"       for (int i = 0; i < sz; i++) {",
			"           for (int j = 0; j < sz; j++) {",
			"               for (int k = 0; k < sz; k++) {",
			"                   res.m[i][j] += m[i][k] * a.m[k][j];",
			"                   res.m[i][j] %= mod;",
			"               }",
			"           }",
			"       }",
			"       return res;",
			"   }",
			"};",
			"",
			"int Fib(int n) {",
			"   Mat res;",
			"   res.identity();",
			"   Mat T;",
			"   T.m[0][0] = T.m[0][1] = T.m[1][0] = 1;",
			"",
			"   if (n <= 2) return 1;",
			"   n -= 2;",
			"",
			"   // log(n)",
			"   while (n) {",
			"       if (n & 1) res = res * T;",
			"       T = T * T;",
			"       n /= 2;",
			"   }",
			"",
			"   return (res.m[0][0] + res.m[0][1]) % mod;",
			"}"
		],
		"description": "matrix exponentiation"
	}
}